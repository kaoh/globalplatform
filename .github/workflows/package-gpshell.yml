name: package gpshell
on:
  workflow_dispatch:
  push:
    tags:
      - '**'

jobs:
  build-linux:
    runs-on: ubuntu-22.04
    steps:
      - name: Set up Git repository
        uses: actions/checkout@v4
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            cmake make gcc g++ pkg-config \
            libpcsclite-dev libssl-dev zlib1g-dev \
            pandoc rpm dpkg-dev \
            libfuse2 curl patchelf
      - name: Prepare AppImage tooling
        run: |
          curl -L -o linuxdeploy \
            https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage
          chmod +x linuxdeploy
      - name: Build dynamic packages
        run: |
          cmake -S . -B build-dynamic -DCMAKE_BUILD_TYPE=Release
          cmake --build build-dynamic -- -j"$(nproc)"
          (cd build-dynamic && cpack -G DEB && cpack -G RPM)
          for f in build-dynamic/gpshell-*; do
            [ -f "$f" ] || continue
            case "$f" in
              *.deb|*.rpm)
                base="${f%.*}"
                ext="${f##*.}"
                mv "$f" "${base}-dynamic.${ext}"
                ;;
            esac
          done
      - name: Build static packages
        run: |
          cmake -S . -B build-static -DCMAKE_BUILD_TYPE=Release -DSTATIC=ON
          cmake --build build-static -- -j"$(nproc)"
          (cd build-static && cpack -G DEB && cpack -G RPM)
          for f in build-static/gpshell-*; do
            [ -f "$f" ] || continue
            case "$f" in
              *.deb|*.rpm)
                base="${f%.*}"
                ext="${f##*.}"
                mv "$f" "${base}-static.${ext}"
                ;;
            esac
          done
          rm -f ./*.AppImage
          cat > gpshell.desktop <<'DESKTOP'
          [Desktop Entry]
          Type=Application
          Name=GPShell
          Exec=gpshell3
          Icon=gpshell
          Terminal=true
          Categories=Utility;
          DESKTOP
          test -f gpshell.png
          export APPIMAGE_EXTRACT_AND_RUN=1
          rm -rf AppDir
          mkdir -p AppDir/usr/bin
          if [ -x build-static/gpshell/src/gpshell3 ]; then
            install -m 0755 build-static/gpshell/src/gpshell3 AppDir/usr/bin/gpshell3
          else
            install -m 0755 build-static/gpshell/src/gpshell3Static AppDir/usr/bin/gpshell3
          fi
          ./linuxdeploy \
            --appdir AppDir \
            -e AppDir/usr/bin/gpshell3 \
            -d gpshell.desktop \
            -i gpshell.png \
            --output appimage
          out=$(ls ./*.AppImage | head -n1)
          ver_current=$(awk '/_CURRENT/ {print $3}' gpshell/CMakeLists.txt | head -n1)
          ver_revision=$(awk '/_REVISION/ {print $3}' gpshell/CMakeLists.txt | head -n1)
          ver_age=$(awk '/_AGE/ {print $3}' gpshell/CMakeLists.txt | head -n1)
          version="${ver_current}.${ver_revision}.${ver_age}"
          if [ -z "$version" ]; then
            echo "Failed to determine version for AppImage name"
            exit 1
          fi
          mv "$out" "gpshell3-${version}.AppImage"
      - name: Sanity test artifacts
        run: |
          set -euo pipefail
          deb_dynamic=$(ls build-dynamic/gpshell-*-dynamic.deb | head -n1)
          deb_static=$(ls build-static/gpshell-*-static.deb | head -n1)
          rpm_dynamic=$(ls build-dynamic/gpshell-*-dynamic.rpm | head -n1)
          rpm_static=$(ls build-static/gpshell-*-static.rpm | head -n1)
          appimage=$(ls gpshell3-*.AppImage | head -n1)

          deb_pkg=$(dpkg-deb -f "$deb_dynamic" Package)
          sudo dpkg -i "$deb_dynamic"
          gpshell3 --help
          sudo dpkg -P "$deb_pkg"

          deb_pkg=$(dpkg-deb -f "$deb_static" Package)
          sudo dpkg -i "$deb_static"
          gpshell3 --help
          sudo dpkg -P "$deb_pkg"

          docker run --rm -v "$PWD:/work" -w /work fedora:39 bash -lc \
            "dnf -y install /work/$rpm_dynamic && gpshell3 --help"
          docker run --rm -v "$PWD:/work" -w /work fedora:39 bash -lc \
            "dnf -y install /work/$rpm_static && gpshell3 --help"

          chmod +x "$appimage"
          APPIMAGE_EXTRACT_AND_RUN=1 "./$appimage" --help
      - name: Save Linux artifacts
        uses: actions/upload-artifact@v4
        with:
          name: gpshell-linux
          path: |
            build-dynamic/*.deb
            build-dynamic/*.rpm
            build-static/*.deb
            build-static/*.rpm
            gpshell3-*.AppImage

  build-windows:
    runs-on: windows-2022
    steps:
      - name: Set up Git repository
        uses: actions/checkout@v4
      - name: Download OpenSSL
        run: |
          $client = new-object System.Net.WebClient
          $client.DownloadFile("https://slproweb.com/download/Win32OpenSSL-3_6_1.msi","C:\Temp\Win32OpenSSL-3_6_1.msi")
      - name: Install dependencies
        shell: cmd
        run: |
          choco install -y doxygen.install graphviz wixtoolset ninja
          C:\Temp\Win32OpenSSL-3_6_1.msi /quiet
          copy "C:\Program Files (x86)\OpenSSL-Win32\lib\VC\x86\MD\*" "C:\Program Files (x86)\OpenSSL-Win32\lib\VC"
      - name: Build dynamic packages
        shell: cmd
        run: |
          call "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\Common7\Tools\VsDevCmd.bat"
          if exist build-dynamic rmdir /S /Q build-dynamic
          cmake -G "Ninja" -DCMAKE_BUILD_TYPE=Release -B build-dynamic -DOPENSSL_ROOT_DIR="C:\Program Files (x86)\OpenSSL-Win32" -DZLIB_ROOT="%cd%\zlib-1.2.8\win32-build"
          cmake --build build-dynamic -- -v
          cmake --build build-dynamic --target doc -- -v
          cd build-dynamic
          cpack -G ZIP
          cpack -G WIX
          ..\windows-bundle.bat
      - name: Rename dynamic packages
        shell: pwsh
        run: |
          Get-ChildItem build-dynamic -File | Where-Object { $_.Name -like "gpshell-*.*" -and $_.Extension } | ForEach-Object {
            $base = $_.FullName.Substring(0, $_.FullName.Length - $_.Extension.Length)
            $ext = $_.Extension.TrimStart('.')
            Rename-Item $_.FullName "$base-dynamic.$ext"
          }
          Get-ChildItem build-dynamic\gpshell-bundle -File | Where-Object { $_.Name -like "gpshell-*.zip" -and $_.Extension } | ForEach-Object {
            $base = $_.FullName.Substring(0, $_.FullName.Length - $_.Extension.Length)
            Rename-Item $_.FullName "$base-dynamic.zip"
          }
      - name: Build static packages
        shell: cmd
        run: |
          call "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\Common7\Tools\VsDevCmd.bat"
          if exist build-static rmdir /S /Q build-static
          cmake -G "Ninja" -DCMAKE_BUILD_TYPE=Release -B build-static -DSTATIC=ON -DOPENSSL_ROOT_DIR="C:\Program Files (x86)\OpenSSL-Win32" -DZLIB_ROOT="%cd%\zlib-1.2.8\win32-build"
          cmake --build build-static -- -v
          cmake --build build-static --target doc -- -v
          cd build-static
          cpack -G ZIP
          cpack -G WIX
      - name: Rename static packages
        shell: pwsh
        run: |
          Get-ChildItem build-static -File | Where-Object { $_.Name -like "gpshell-*.*" -and $_.Extension } | ForEach-Object {
            $base = $_.FullName.Substring(0, $_.FullName.Length - $_.Extension.Length)
            $ext = $_.Extension.TrimStart('.')
            Rename-Item $_.FullName "$base-static.$ext"
          }
      - name: Sanity test artifacts
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $msi = Get-ChildItem build-static -Filter "gpshell-*-static.msi" | Select-Object -First 1
          if (-not $msi) { throw "Static MSI not found" }
          Start-Process msiexec -ArgumentList "/i `"$($msi.FullName)`" /qn /norestart" -Wait -NoNewWindow

          $exe = $null
          $roots = @($Env:ProgramFiles, ${Env:ProgramFiles(x86)})
          foreach ($root in $roots) {
            if (-not $root) { continue }
            $dirs = Get-ChildItem $root -Directory -Filter "gpshell*" -ErrorAction SilentlyContinue
            foreach ($dir in $dirs) {
              $candidate = Join-Path $dir.FullName "bin\gpshell3.exe"
              if (Test-Path $candidate) { $exe = $candidate; break }
              $candidate = Join-Path $dir.FullName "gpshell3.exe"
              if (Test-Path $candidate) { $exe = $candidate; break }
            }
            if ($exe) { break }
          }
          if (-not $exe) { throw "gpshell3.exe not found after MSI install" }
          & $exe --help

          $zip = Get-ChildItem build-static -Filter "gpshell-*-static.zip" | Select-Object -First 1
          if (-not $zip) { throw "Static ZIP not found" }
          $zipDir = Join-Path $env:TEMP "gpshell-static-zip"
          if (Test-Path $zipDir) { Remove-Item -Recurse -Force $zipDir }
          Expand-Archive -Path $zip.FullName -DestinationPath $zipDir -Force
          $zipExe = Get-ChildItem $zipDir -Recurse -Filter "gpshell3.exe" | Select-Object -First 1
          if (-not $zipExe) { throw "gpshell3.exe not found in static ZIP" }
          & $zipExe.FullName --help

          $bundle = Get-ChildItem build-dynamic\gpshell-bundle -Filter "gpshell-*-dynamic.zip" | Select-Object -First 1
          if (-not $bundle) { throw "Bundle ZIP not found" }
          $bundleDir = Join-Path $env:TEMP "gpshell-bundle"
          if (Test-Path $bundleDir) { Remove-Item -Recurse -Force $bundleDir }
          Expand-Archive -Path $bundle.FullName -DestinationPath $bundleDir -Force
          $bundleExe = Get-ChildItem $bundleDir -Recurse -Filter "gpshell3.exe" | Select-Object -First 1
          if (-not $bundleExe) { throw "gpshell3.exe not found in bundle ZIP" }
          & $bundleExe.FullName --help
      - name: Build MSIX package (self-signed demo)
        shell: powershell
        run: |
          $ErrorActionPreference = "Stop"

          $zip = Get-ChildItem build-static -Filter "gpshell-*-static.zip" | Select-Object -First 1
          if (-not $zip) { throw "Static ZIP not found; cannot build MSIX" }

          # One-off self-signed cert for demonstration.
          # The MSIX manifest Publisher must exactly match the certificate subject.
          $cert = New-SelfSignedCertificate `
            -Type CodeSigningCert `
            -Subject "CN=GPShell Demo" `
            -CertStoreLocation "Cert:\CurrentUser\My" `
            -KeyAlgorithm RSA `
            -KeyLength 2048 `
            -HashAlgorithm SHA256 `
            -KeyExportPolicy Exportable `
            -NotAfter (Get-Date).AddYears(1)

          $pfxPasswordPlain = [Guid]::NewGuid().ToString("N")
          $pfxPassword = ConvertTo-SecureString -String $pfxPasswordPlain -Force -AsPlainText
          $pfxPath = Join-Path $zip.DirectoryName ($zip.BaseName + ".pfx")
          $cerPath = Join-Path $zip.DirectoryName ($zip.BaseName + ".cer")
          Export-PfxCertificate -Cert $cert -FilePath $pfxPath -Password $pfxPassword | Out-Null
          Export-Certificate -Cert $cert -FilePath $cerPath | Out-Null

          function Get-WindowsSdkToolPath([string]$toolName) {
            $cmd = Get-Command $toolName -ErrorAction SilentlyContinue
            if ($cmd) { return $cmd.Source }

            $roots = @(
              (Join-Path ${env:ProgramFiles(x86)} "Windows Kits\\10\\bin")
              (Join-Path ${env:ProgramFiles(x86)} "Windows Kits\\11\\bin")
            ) | Where-Object { Test-Path $_ }

            foreach ($root in $roots) {
              $versions = Get-ChildItem $root -Directory | Sort-Object Name -Descending
              foreach ($ver in $versions) {
                $candidate = Join-Path $ver.FullName ("x64\\" + $toolName)
                if (Test-Path $candidate) { return $candidate }
              }
              $fallback = Join-Path $root ("x64\\" + $toolName)
              if (Test-Path $fallback) { return $fallback }
            }

            throw "$toolName not found (Windows SDK not installed?)"
          }

          $makeappx = Get-WindowsSdkToolPath "makeappx.exe"
          $signtool = Get-WindowsSdkToolPath "signtool.exe"

          $srcDir = Join-Path $env:TEMP ("gpshell-msix-src-" + [Guid]::NewGuid().ToString("N"))
          $msixRoot = Join-Path $env:TEMP ("gpshell-msix-root-" + [Guid]::NewGuid().ToString("N"))
          New-Item -ItemType Directory -Path $srcDir | Out-Null
          New-Item -ItemType Directory -Path $msixRoot | Out-Null

          try {
            Expand-Archive -Path $zip.FullName -DestinationPath $srcDir -Force
            $payloadDir = Get-ChildItem $srcDir -Directory -Filter "gpshell-*" | Select-Object -First 1
            if (-not $payloadDir) { throw "Expected gpshell-* directory inside $($zip.Name)" }

            Copy-Item -Path (Join-Path $payloadDir.FullName "*") -Destination $msixRoot -Recurse -Force

            $exe = Get-ChildItem $msixRoot -Recurse -Filter "gpshell3.exe" | Select-Object -First 1
            if (-not $exe) { throw "gpshell3.exe not found in MSIX payload" }
            # Compute a path relative to the package root. Avoid substring-by-length because
            # paths can be rendered with short (8.3) names in different parts of the pipeline.
            $exeFull = ($exe.FullName -replace "/", "\\")
            $rootLeaf = Split-Path $msixRoot -Leaf
            $marker = $rootLeaf + "\"
            $markerIndex = $exeFull.IndexOf($marker, [System.StringComparison]::OrdinalIgnoreCase)
            if ($markerIndex -ge 0) {
              $exeRel = $exeFull.Substring($markerIndex + $marker.Length)
            } else {
              $rootFull = (($msixRoot -replace "/", "\\").TrimEnd("\\"))
              if (-not $exeFull.StartsWith($rootFull, [System.StringComparison]::OrdinalIgnoreCase)) {
                throw "Failed to compute relative path for gpshell3.exe (root: $msixRoot exe: $($exe.FullName))"
              }
              $exeRel = $exeFull.Substring($rootFull.Length).TrimStart("\\")
            }

            # Generate MSIX assets from the repo icon.
            $repoIcon = Join-Path $pwd "gpshell.png"
            if (-not (Test-Path $repoIcon)) { throw "Missing repo icon: $repoIcon" }
            $assetsDir = Join-Path $msixRoot "Assets"
            New-Item -ItemType Directory -Path $assetsDir -Force | Out-Null

            Add-Type -AssemblyName System.Drawing
            function Write-ResizedPng([string]$source, [string]$dest, [int]$width, [int]$height) {
              $img = [System.Drawing.Image]::FromFile($source)
              try {
                $bmp = New-Object System.Drawing.Bitmap $width, $height
                try {
                  $g = [System.Drawing.Graphics]::FromImage($bmp)
                  try {
                    $g.Clear([System.Drawing.Color]::Transparent)
                    $g.InterpolationMode = [System.Drawing.Drawing2D.InterpolationMode]::HighQualityBicubic
                    $g.SmoothingMode = [System.Drawing.Drawing2D.SmoothingMode]::HighQuality
                    $g.PixelOffsetMode = [System.Drawing.Drawing2D.PixelOffsetMode]::HighQuality

                    $ratio = [Math]::Min($width / $img.Width, $height / $img.Height)
                    $newW = [int]([Math]::Round($img.Width * $ratio))
                    $newH = [int]([Math]::Round($img.Height * $ratio))
                    $x = [int](($width - $newW) / 2)
                    $y = [int](($height - $newH) / 2)

                    $g.DrawImage($img, $x, $y, $newW, $newH)
                  } finally {
                    $g.Dispose()
                  }
                  $bmp.Save($dest, [System.Drawing.Imaging.ImageFormat]::Png)
                } finally {
                  $bmp.Dispose()
                }
              } finally {
                $img.Dispose()
              }
            }

            Write-ResizedPng $repoIcon (Join-Path $assetsDir "Square44x44Logo.png") 44 44
            Write-ResizedPng $repoIcon (Join-Path $assetsDir "Square150x150Logo.png") 150 150
            Write-ResizedPng $repoIcon (Join-Path $assetsDir "Wide310x150Logo.png") 310 150
            Write-ResizedPng $repoIcon (Join-Path $assetsDir "Square310x310Logo.png") 310 310
            Write-ResizedPng $repoIcon (Join-Path $assetsDir "StoreLogo.png") 50 50

            # Derive an MSIX-compatible 4-part version from the CPack ZIP name.
            $ver3 = ($zip.BaseName -replace '^gpshell-','' -replace '-static$','')
            $verParts = $ver3.Split('.')
            if ($verParts.Count -eq 3) { $msixVersion = "$ver3.0" }
            elseif ($verParts.Count -eq 4) { $msixVersion = $ver3 }
            else { $msixVersion = "0.0.0.0" }

            $publisher = $cert.Subject
            $manifestPath = Join-Path $msixRoot "AppxManifest.xml"
            @"
          <?xml version="1.0" encoding="utf-8"?>
          <Package xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10"
                   xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10"
                   xmlns:rescap="http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities"
                   IgnorableNamespaces="uap rescap">
            <Identity Name="org.globalplatform.gpshell3"
                      Publisher="$publisher"
                      Version="$msixVersion" />
            <Properties>
              <DisplayName>GPShell</DisplayName>
              <PublisherDisplayName>GPShell</PublisherDisplayName>
              <Description>GlobalPlatform GPShell</Description>
              <Logo>Assets\StoreLogo.png</Logo>
            </Properties>
            <Dependencies>
              <TargetDeviceFamily Name="Windows.Desktop"
                                  MinVersion="10.0.17763.0"
                                  MaxVersionTested="10.0.26100.0" />
            </Dependencies>
            <Resources>
              <Resource Language="en-us" />
            </Resources>
            <Applications>
              <Application Id="GPShell"
                           Executable="$exeRel"
                           EntryPoint="Windows.FullTrustApplication">
                <uap:VisualElements
                  DisplayName="GPShell"
                  Description="GlobalPlatform GPShell"
                  BackgroundColor="transparent"
                  Square44x44Logo="Assets\Square44x44Logo.png"
                  Square150x150Logo="Assets\Square150x150Logo.png">
                  <uap:DefaultTile
                    Wide310x150Logo="Assets\Wide310x150Logo.png"
                    Square310x310Logo="Assets\Square310x310Logo.png" />
                </uap:VisualElements>
              </Application>
            </Applications>
            <Capabilities>
              <rescap:Capability Name="runFullTrust" />
            </Capabilities>
          </Package>
          "@ | Set-Content -Path $manifestPath -Encoding UTF8

            $msixPath = Join-Path $zip.DirectoryName ($zip.BaseName + ".msix")
            & $makeappx pack /d $msixRoot /p $msixPath /o | Out-Host

            & $signtool sign /fd SHA256 /f $pfxPath /p $pfxPasswordPlain $msixPath | Out-Host
          }
          finally {
            if (Test-Path $srcDir) { Remove-Item -Recurse -Force $srcDir }
            if (Test-Path $msixRoot) { Remove-Item -Recurse -Force $msixRoot }
            if (Test-Path $pfxPath) { Remove-Item -Force $pfxPath }
          }
      - name: Save Windows artifacts
        uses: actions/upload-artifact@v4
        with:
          name: gpshell-windows
          path: |
            build-dynamic/*.zip
            build-dynamic/*.msi
            build-dynamic/gpshell-bundle/*.zip
            build-static/*.cer
            build-static/*.zip
            build-static/*.msix
            build-static/*.msi

  build-macos:
    runs-on: macos-latest
    steps:
      - name: Set up Git repository
        uses: actions/checkout@v4
      - name: Install dependencies
        run: |
          brew update
          brew install cmake pkg-config openssl@3 pandoc
      - name: Build dynamic packages
        run: |
          OPENSSL_ROOT_DIR=$(brew --prefix openssl@3)
          cmake -S . -B build-dynamic -DCMAKE_BUILD_TYPE=Release -DOPENSSL_ROOT_DIR="${OPENSSL_ROOT_DIR}"
          cmake --build build-dynamic -- -j"$(sysctl -n hw.ncpu)"
          (cd build-dynamic && cpack -G DragNDrop)
          for f in build-dynamic/gpshell-*.dmg; do
            [ -f "$f" ] || continue
            base="${f%.*}"
            mv "$f" "${base}-dynamic.dmg"
          done
      - name: Build static packages
        run: |
          OPENSSL_ROOT_DIR=$(brew --prefix openssl@3)
          cmake -S . -B build-static -DCMAKE_BUILD_TYPE=Release -DSTATIC=ON -DOPENSSL_ROOT_DIR="${OPENSSL_ROOT_DIR}"
          cmake --build build-static -- -j"$(sysctl -n hw.ncpu)"
          (cd build-static && cpack -G DragNDrop)
          for f in build-static/gpshell-*.dmg; do
            [ -f "$f" ] || continue
            base="${f%.*}"
            mv "$f" "${base}-static.dmg"
          done
      - name: Sanity test artifacts
        run: |
          set -euo pipefail
          for dmg in build-static/gpshell-*-static.dmg build-dynamic/gpshell-*-dynamic.dmg; do
            [ -f "$dmg" ] || { echo "Missing dmg: $dmg"; exit 1; }
            dmg_id=$(basename "$dmg" .dmg | tr -c 'A-Za-z0-9._-' '_')
            mnt="/tmp/gpshell-mount-${dmg_id}-$$"
            rm -rf "$mnt"
            mkdir -p "$mnt"
            if ! hdiutil attach -nobrowse -readonly -noautoopen -noverify -mountpoint "$mnt" "$dmg" >/tmp/hdiutil-attach.log 2>&1; then
              echo "Failed to attach $dmg"
              cat /tmp/hdiutil-attach.log
              exit 1
            fi
            exe=$(find "$mnt" -type f -name gpshell3 | head -n1)
            if [ -z "$exe" ]; then
              hdiutil detach "$mnt" >/dev/null || true
              rm -rf "$mnt"
              echo "gpshell3 not found in $dmg"
              exit 1
            fi
            "$exe" --help
            hdiutil detach "$mnt" >/dev/null
            rm -rf "$mnt"
          done
      - name: Save macOS artifacts
        uses: actions/upload-artifact@v4
        with:
          name: gpshell-macos
          path: |
            build-dynamic/*.dmg
            build-static/*.dmg

  publish-release:
    runs-on: ubuntu-22.04
    needs:
      - build-linux
      - build-windows
      - build-macos
    if: startsWith(github.ref, 'refs/tags/')
    permissions:
      contents: write
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist
      - name: Collect release assets
        run: |
          set -euo pipefail
          mkdir -p release-assets
          cp -v dist/gpshell-linux/build-static/*.deb release-assets/
          cp -v dist/gpshell-linux/build-static/*.rpm release-assets/
          cp -v dist/gpshell-windows/build-static/*.msi release-assets/
          cp -v dist/gpshell-windows/build-static/*.msix release-assets/
          cp -v dist/gpshell-windows/build-static/*.cer release-assets/
          cp -v dist/gpshell-windows/build-static/*-static.zip release-assets/
          cp -v dist/gpshell-macos/build-static/*.dmg release-assets/
      - name: Generate SHA256 checksums
        run: |
          set -euo pipefail
          (cd release-assets && sha256sum * > SHA256SUMS)
      - name: Publish assets to GitHub release
        env:
          GH_TOKEN: ${{ github.token }}
          TAG_NAME: ${{ github.ref_name }}
        run: |
          set -euo pipefail
          if gh release view "$TAG_NAME" --repo "$GITHUB_REPOSITORY" >/dev/null 2>&1; then
            echo "Release $TAG_NAME already exists; uploading assets without changing prerelease status."
            gh release upload "$TAG_NAME" release-assets/** --clobber --repo "$GITHUB_REPOSITORY"
          else
            echo "Release $TAG_NAME does not exist; creating a draft release with assets."
            gh release create "$TAG_NAME" release-assets/** --draft --title "$TAG_NAME" --repo "$GITHUB_REPOSITORY"
          fi
